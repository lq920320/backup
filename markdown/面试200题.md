2. `==` 和 `equals` 的区别是什么？

   `==` 是运算符，用于比较两个变量是否相等，而 `equals` 是 `Object` 类的方法，用于比较两个对象是否相等。默认 `Object` 类的 `equals` 方法是比较两个对象的地址，此时和 `==` 的结果一样。换句话说：基本类型比较用 `==` ，比较的是他们的值。默认下，对象用 `==` 比较时，比较的是内存地址，如果需要比较对象内容，需要重写 `equal` 方法。

3.  两个对象的 `hashCode()` 相同，则 `equals()` 也一定为 `true`，对吗？

   不一定。反过来，`equals` 为 `true`，`hashCode` 也不一定相同。类的 `hashCode` 方法和 `equals` 方法都可以重写，返回的值完全在于自己定义。

   `hashCode()` 返回该对象的哈希码值；`equals()` 返回两个对象是否相等。

   关于 `hashCode()` 和 `equals()` 方法是由一些常规协定的：

   1. 两个对象用 `equals()` 比较返回 `true` ，那么两个对象的 `hashCode()` 方法必须返回相同的结果。
   2. 两个对象用 `equals()` 比较返回 `false`，不要求 `hashCode()` 方法也一定返回不同的值，但是最好返回不同值，以提高哈希表性能。
   3. 重写 `equals()` 方法，必须重写 `hashCode()` 方法，以保证 `equals()` 方法相等时两个对象 `hashCode()` 返回相同的值。

4. `final` 在 `java` 中有什么作用？

   `final` 可用于修饰数据、方法以及类。

   1） 数据

   声明数据为常量时，可以是编译时的常量，也可以是在运行时被初始化后不能被改变的常量。

   - 对于基本类型，final 使数值不变
   - 对于引用类型，final 使引用不变，也就不能引用其他对象，但是被引用的对象本身是可以被修改的。

   2） 方法

   声明方法不能被子类重写。

   private 方法隐式地被指定为final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

   3） 类

   声明类不允许被继承。final 类中的所有成员方法都会被隐式地指定为final方法。

5. `java` 中的 `Math.round(-1.5) ` 等于多少？

   `-1`。

   `Math` 类中提供了三个与取整有关的方法：
   `ceil`   天花板，向上取整
   `floor`  地板，向下取整
   `round`  四舍五入

6. `String` 属于基础的数据类型吗？

   不属于，这是 `string` 的包装类，是 `final` 修饰的 `java` 类，是引用类型。

7. `java` 中操作字符串都有哪些类？它们之间有什么区别？

   `String`、`StringBuffer`、`StringBuilder`

   - `String` ： `final` 修饰，`String` 类的方法返回的都是 `new String`。即对 `String` 对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。
   - `StringBuffer`：对字符串的操作方法都加了 `synchornized` 关键字，保证线程安全。
   - `StringBuilder`：不保证线程安全，在方法体内需要进行字符串的修改操作，可以 `new StringBuilder` 对象，调用 `StringBuilder` 对象的 `append`、`replace`、`delete` 等方法修改字符串。

8. `String str="i";`与 `String str=new String("i");`一样吗？

   不一样。一个是常量值，一个是新建了 `String` 对象；一个在常量池，一个在堆中。

9. 如何将字符串反转？

10. String 类的常用方法都有哪些？

11. 抽象类必须要有抽象方法吗？

    抽象类可以没有抽象方法，但是如果你的一个类已经声明成了抽象类，即使这个类中没有抽象方法，它也不能再实例化，即不能直接构造一个该类的对象。
    如果一个类中有了一个抽象方法，那么这个类必须声明为抽象类，否则编译通不过。

12. 普通类和抽象类有哪些区别？

    1. 抽象类不能被实例化。
    2. 抽象类可以有构造函数，被继承时子类必须继承父类一个构造方法，抽象方法不能被声明为静态。
    3. 抽象方法只需声明，而无需实现，抽象类中可以允许普通方法有主体。
    4. 含有抽象方法的类必须声明为抽象类。
    5. 抽象的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类。

    抽象类是否可以有构造函数？答案是可以有。抽象类的构造函数用来初始化抽象类的一些字段，而这一切都在抽象类的派生类实例化之前发生。不仅如此，抽象类的构造函数还有一种巧妙应用：就是在其内部实现子类必须执行的代码。

13. 抽象类能使用 final 修饰吗？

    不能，抽象类是被用于继承的，final 修饰代表不可修改、不可继承的。

14. 接口和抽象类有什么区别？

15. `java` 中 IO 流分几种？

    - 按照流的流向分，可以分为输入流和输出流；
    - 按照操作单元分，可以划分为字节流和字符流；
    - 按照流的角色划分为节点流和处理流。

    Java IO 流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系，Java IO 流的40多个类都是从如下4个抽象类基类中派生出来的。

    - `InputStream/Reader`：所有的输入流的基类，前者是字节输入流，后者是字符输入流。
    - `OutputStream/Writer`：所有输出流的基类，前者是字节输出流，后者是字符输出流。

16. `BIO`、`NIO`、`AIO` 有什么区别？

    - `BIO (Blocking I/O)`： 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 `BIO` 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
    - `NIO (New I/O)`： `NIO` 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 `NIO` 框架，对应 java.nio 包，提供了 Channel，Selector，Buffer 等抽象。NIO 中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。
    - `AIO (Asynchronous I/O)`： `AIO` 也就是 `NIO 2`。在 Java 7 中引入了 `NIO` 的改进版 `NIO 2`，它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。

17. Files的常用方法都有哪些？

    - Files.exists() 检测文件路径是否存在
    - Files.createFile()创建文件
    - Files.cteateDirectory()创建文件夹
    - Files.delete() 删除文件或者目录
    - Files.copy() 复制文件
    - Files.move() 移动文件
    - Files.size（）查看文件个数
    - Files.read() 读取文件
    - Files.write()写入文件